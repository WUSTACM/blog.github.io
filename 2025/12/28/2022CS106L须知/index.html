<!DOCTYPE html>
<html lang="zh-CN,en,default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/2025-12-21-2.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/2025-12-21-1.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.wustacm.org","root":"/","scheme":"Gemini","version":"7.8.0","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="CS106L须知 CS106L非常适合想学习工程化C++的同学，注重标准库（STL）、RAII、智能指针、移动语义等。在其中我们会学到很多现代C++的东西以及基础的类的相关知识，都是一些非常有意思的东西，会让大家眼前焕然一新。">
<meta property="og:type" content="article">
<meta property="og:title" content="2022CS106L须知">
<meta property="og:url" content="http://blog.wustacm.org/2025/12/28/2022CS106L%E9%A1%BB%E7%9F%A5/index.html">
<meta property="og:site_name" content="WUSTACM">
<meta property="og:description" content="CS106L须知 CS106L非常适合想学习工程化C++的同学，注重标准库（STL）、RAII、智能指针、移动语义等。在其中我们会学到很多现代C++的东西以及基础的类的相关知识，都是一些非常有意思的东西，会让大家眼前焕然一新。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-12-28T00:00:00.000Z">
<meta property="article:modified_time" content="2026-01-04T18:24:44.227Z">
<meta property="article:author" content="Blog">
<meta property="article:tag" content="cs106l">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://blog.wustacm.org/2025/12/28/2022CS106L%E9%A1%BB%E7%9F%A5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>2022CS106L须知 | WUSTACM</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta custom-logo">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">WUSTACM</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <a>
        <img class="custom-logo-image" src="/images/2025-12-21-3.png" alt="WUSTACM">
      </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL1dVU1RBQ00=" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.wustacm.org/2025/12/28/2022CS106L%E9%A1%BB%E7%9F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WUSTACM">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          2022CS106L须知
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-12-28 00:00:00" itemprop="dateCreated datePublished" datetime="2025-12-28T00:00:00+00:00">2025-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-01-04 18:24:44" itemprop="dateModified" datetime="2026-01-04T18:24:44+00:00">2026-01-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">技术分享</span></a>
                </span>
            </span>

          
            <span id="/2025/12/28/2022CS106L%E9%A1%BB%E7%9F%A5/" class="post-meta-item leancloud_visitors" data-flag-title="2022CS106L须知" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2025/12/28/2022CS106L%E9%A1%BB%E7%9F%A5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2025/12/28/2022CS106L%E9%A1%BB%E7%9F%A5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>23 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="cs106l须知">CS106L须知</h1>
<p>CS106L非常适合想学习工程化C++的同学，注重标准库（STL）、RAII、智能指针、移动语义等。在其中我们会学到很多现代C++的东西以及基础的类的相关知识，都是一些非常有意思的东西，会让大家眼前焕然一新。</p>
<span id="more"></span>
<h3 id="与cs106b的关系">与CS106B的关系</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CS106B：编程抽象（C++基础 + 数据结构）</span><br><span class="line">    ↓</span><br><span class="line">CS106L：标准 C++ 编程实验室（深入 C++ 特性）</span><br><span class="line">    ↓</span><br><span class="line">CS106X：编程抽象加速版（更高级）</span><br></pre></td></tr></table></figure>
<h1 id="在cs106l中会学到的一些知识">在CS106L中会学到的一些知识</h1>
<p>智能指针的笔记在后面，仅列出本人学到的知识以及我觉得比较重要的知识。</p>
<h1 id="auto的类型">auto的类型</h1>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> multiplier = <span class="number">2.4</span>;  <span class="comment">//double</span></span><br><span class="line"><span class="keyword">auto</span> name = <span class="string">&quot;Fanan&quot;</span>; <span class="comment">//char* (c-string)</span></span><br><span class="line"><span class="keyword">auto</span> bettername = string&#123;<span class="string">&quot;Fanan&quot;</span>&#125;; <span class="comment">//string</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; bettername1 = string&#123;<span class="string">&quot;Fanan&quot;</span>&#125; <span class="comment">//const string&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp; refMult = multiplier; <span class="comment">//double&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> func = [](<span class="keyword">auto</span> i) &#123;</span><br><span class="line">    <span class="keyword">return</span> i * <span class="number">2</span>;</span><br><span class="line">&#125;; <span class="comment">//lambda</span></span><br></pre></td></tr></table></figure>
<h1 id="algorithm">algorithm</h1>
<h2 id="stdsort">(1) std::sort</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::sort这个大家或多或少都有接触过的吧</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; num = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="type">int</span>&amp; a, <span class="type">const</span> <span class="type">int</span>&amp; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="stdnth_element">(2) std::nth_element</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">给定一个容器（如vector）和一个位置nth，将容器中 “第 n 个元素” 放到完全排序后它应该在的位置；</span></span><br><span class="line"><span class="comment">该位置左侧的所有元素都 ≤ 它（默认升序），右侧的所有元素都 ≥ 它；</span></span><br><span class="line"><span class="comment">左右两侧的元素不保证有序（这是和sort的核心区别），但能保证nth位置的元素是 “正确值”。</span></span><br><span class="line"><span class="comment">复杂度O(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> nth_pos = nums.<span class="built_in">begin</span>() + <span class="number">2</span>;</span><br><span class="line">std::<span class="built_in">nth_element</span>(nums.<span class="built_in">begin</span>(), nth_pos, nums.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//nums将会变成 2 1 3 7 5 4 8 9 6（3在正确位置，左右分别≤/≥3）</span></span><br></pre></td></tr></table></figure>
<h2 id="stdstable_partition">(3) std::stable_partition</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将容器中的元素按「自定义条件（谓词）」分成两部分：满足条件的元素在前，不满足的在后；</span></span><br><span class="line"><span class="comment">关键特性：两部分内部的元素会保持原有的相对顺序（“stable” 的核心含义）；</span></span><br><span class="line"><span class="comment">对比普通std::partition：后者仅完成分区，但不保证两部分内部的顺序，而stable_partition会保留顺序（代价是时间 / 空间复杂度略高）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> partition_it = std::<span class="built_in">stable_partition</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">int</span> a) &#123;</span><br><span class="line">    <span class="keyword">return</span> a % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = nums.<span class="built_in">begin</span>(); it != partition_it; ++it) &#123;</span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出：2 4 8（和原数组中偶数出现的顺序一致）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = partition_it; it != nums.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出：7 9 5（和原数组中奇数出现的顺序一致）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="stdcopy_if">(4) std::copy_if</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">从源容器中遍历元素，只将满足自定义条件（谓词） 的元素拷贝到目标容器中；</span></span><br><span class="line"><span class="comment">不修改原容器，仅做 “筛选 + 拷贝”，属于 “非修改型算法”；</span></span><br><span class="line"><span class="comment">对比std::copy：std::copy拷贝所有元素，std::copy_if只拷贝满足条件的元素，灵活性更高。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; src = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="comment">// 目标容器（提前为空，用back_inserter自动插入),如果容器不空，他会自动在容器后面添加</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; dest;</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">copy_if</span>(src.<span class="built_in">begin</span>(), src.<span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(dest), [](<span class="type">int</span> a) &#123;</span><br><span class="line">    <span class="keyword">return</span> a % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;拷贝的偶数：&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : dest) &#123;</span><br><span class="line">    std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出：2 4 6 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="stdremove_if">(5) std::remove_if</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">核心作用：遍历容器，将不满足移除条件的元素向前移动（覆盖），把满足移除条件的元素挤到容器末尾；</span></span><br><span class="line"><span class="comment">关键特性：不实际删除元素，也不改变容器的size()，仅改变元素位置；</span></span><br><span class="line"><span class="comment">返回值：指向容器中 “第一个需要被删除的元素” 的迭代器（即末尾待删除区域的起始位置）；</span></span><br><span class="line"><span class="comment">对比std::copy_if：</span></span><br><span class="line"><span class="comment">	1.copy_if：拷贝满足条件的元素到新容器，不修改原容器；</span></span><br><span class="line"><span class="comment">	2.remove_if：原地移动元素，修改原容器内容，但需配合erase才会真正删除元素。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">std::cout &lt;&lt; nums.<span class="built_in">size</span>() &lt;&lt; std::endl; <span class="comment">//输出6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">remove_if</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">int</span> a) &#123;</span><br><span class="line">    <span class="keyword">return</span> a &amp; <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line">std::cout &lt;&lt; nums.<span class="built_in">size</span>() &lt;&lt; std::endl; <span class="comment">//输出6，顺序为1 3 5 2 4 6</span></span><br><span class="line"></span><br><span class="line">nums.<span class="built_in">erase</span>(it, nums.<span class="built_in">end</span>());</span><br><span class="line">std::cout &lt;&lt; nums.<span class="built_in">size</span>() &lt;&lt; std::endl; <span class="comment">//输出3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以连起来写</span></span><br><span class="line">nums.<span class="built_in">erase</span>(</span><br><span class="line">	std::<span class="built_in">remove_if</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), </span><br><span class="line">    	[](<span class="type">int</span> a) &#123;<span class="keyword">return</span> a &amp; <span class="number">1</span>;&#125;),</span><br><span class="line">    nums.<span class="built_in">end</span>()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="transform">(6) transform</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果大家打过算法竞赛的话，应该有接触过一点点，比如</span></span><br><span class="line">string s = <span class="string">&quot;Fanan&quot;</span>;</span><br><span class="line"><span class="built_in">transform</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), s.<span class="built_in">begin</span>(), ::tolower);</span><br><span class="line"><span class="comment">//这是一个把字符串中所有字符都小写的一个写法，这就是一个典型的transform的一元操作。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt, <span class="keyword">class</span> OutputIt, <span class="keyword">class</span> UnaryOperation &gt;</span></span><br><span class="line"><span class="function">OutputIt <span class="title">transform</span><span class="params">( InputIt first1, InputIt last1, </span></span></span><br><span class="line"><span class="params"><span class="function">                    OutputIt d_first, UnaryOperation unary_op )</span></span>;</span><br><span class="line"><span class="comment">//first1,last1分别是迭代器的头跟尾，d_first是最后写入哪里，unary_op是操作。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; src = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">dst</span><span class="params">(src.size())</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将每个元素乘以2</span></span><br><span class="line">    std::<span class="built_in">transform</span>(src.<span class="built_in">begin</span>(), src.<span class="built_in">end</span>(), dst.<span class="built_in">begin</span>(),</span><br><span class="line">                   [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x * <span class="number">2</span>; &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：2 4 6 8 10</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : dst) std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//transform的二元操作</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt1, <span class="keyword">class</span> InputIt2, <span class="keyword">class</span> OutputIt, <span class="keyword">class</span> BinaryOperation &gt;</span></span><br><span class="line"><span class="function">OutputIt <span class="title">transform</span><span class="params">( InputIt1 first1, InputIt1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                    InputIt2 first2, OutputIt d_first,</span></span></span><br><span class="line"><span class="params"><span class="function">                    BinaryOperation binary_op )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(a.size())</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将两个vector对应元素相加</span></span><br><span class="line">    std::<span class="built_in">transform</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), result.<span class="built_in">begin</span>(),</span><br><span class="line">                   [](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：11 22 33 44 55</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : result) std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们也可以使用back_inserter(result)来写，可以看上面的copy_if</span></span><br></pre></td></tr></table></figure>
<h1 id="ranges">ranges</h1>
<h2 id="一定义与核心定位">一、定义与核心定位</h2>
<p>std::ranges::views（简称 views）是 C++20 标准库中 <code>ranges</code>
模块的核心组件之一，本质是对“范围（range）”的轻量级、惰性求值的适配层。其核心作用是：在不修改原始数据、不产生中间拷贝的前提下，对范围（如容器、数组、生成器等）进行过滤、转换、切片等操作，最终生成一个新的“视图”供后续使用。</p>
<p>视图本身不存储数据，仅保存对原始范围的引用（或迭代器对）以及操作逻辑。只有当视图被遍历（如通过循环、算法迭代）时，相关操作才会被实际执行——这种“惰性求值”特性是
views 与传统算法（如
<code>std::transform</code>、<code>std::filter</code>）的核心区别，也是其高效性的关键。</p>
<h2 id="二核心特性">二、核心特性</h2>
<h3 id="惰性求值lazy-evaluation">1. 惰性求值（Lazy Evaluation）</h3>
<p>视图的创建和组合操作本身不执行任何计算，仅记录操作逻辑。只有当视图被“消费”（如迭代、取值）时，才会逐元素应用所有操作。例如：将
<code>views::filter</code> 与 <code>views::transform</code>
组合后，遍历视图时会先过滤元素，再对符合条件的元素执行转换，而非先过滤生成中间容器，再转换中间容器。</p>
<h3 id="无存储轻量级">2. 无存储、轻量级</h3>
<p>视图不持有数据，仅保存对原始范围的引用和操作状态（如过滤条件、转换函数、切片位置等），因此创建视图的开销极低（通常为常数时间
O(1)），内存占用可忽略。</p>
<h3 id="不可修改原始数据">3. 不可修改原始数据</h3>
<p>视图默认是“只读”的（除非显式使用可修改视图，如
<code>views::as_rvalue</code>），所有操作仅作用于遍历过程中的元素临时值，不会改变原始范围的数据。</p>
<h3 id="可组合性composability">4. 可组合性（Composability）</h3>
<p>多个视图可以通过“管道运算符（|）”轻松组合，形成清晰的操作流水线。例如
<code>range | views::filter(...) | views::transform(...) | views::take(...)</code>，逻辑上等同于“先过滤、再转换、最后取前
N 个元素”，代码简洁且可读性高。</p>
<h3 id="兼容标准算法">5. 兼容标准算法</h3>
<p>视图本身是“范围（range）”，可直接作为标准范围算法（如
<code>std::ranges::for_each</code>、<code>std::ranges::count</code>）的输入，无需额外适配。</p>
<h2 id="三常见视图类型及使用示例">三、常见视图类型及使用示例</h2>
<p><code>AI</code> 告诉我可以写成 <code>std::views::filter</code>
但是我觉得还是写 <code>std::ranges::views::filter</code>
好一点，因为我写的时候报错了。</p>
<p>C++20
标准库提供了数十种内置视图，覆盖过滤、转换、切片、拼接、生成等常见场景，以下是最常用的几种：</p>
<h3 id="过滤视图viewsfilter">1. 过滤视图：views::filter</h3>
<p>功能：筛选出符合条件的元素，接收一个返回 bool 的谓词函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ranges&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="comment">// 筛选偶数</span></span><br><span class="line">    <span class="keyword">auto</span> even_nums = nums | std::ranges::views::<span class="built_in">filter</span>([](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>; &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : even_nums) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出：2 4 6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h3 id="转换视图viewstransform">2. 转换视图：views::transform</h3>
<p>功能：对每个元素执行转换操作，接收一个转换函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ranges&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="comment">// 将每个元素乘以 2</span></span><br><span class="line">    <span class="keyword">auto</span> doubled = nums | std::ranges::views::<span class="built_in">transform</span>([](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x * <span class="number">2</span>; &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : doubled) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出：2 4 6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h3 id="切片视图viewstake-与-viewsdrop">3. 切片视图：views::take 与
views::drop</h3>
<p>-<code>views::take(n)</code>：取前 n 个元素，若不足 n
个则取全部；</p>
<p>- <code>views::drop(n)</code>：跳过前 n 个元素，取剩余元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ranges&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 取前 3 个元素</span></span><br><span class="line">    <span class="keyword">auto</span> take3 = nums | std::ranges::views::<span class="built_in">take</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 跳过前 2 个元素，取剩余</span></span><br><span class="line">    <span class="keyword">auto</span> drop2 = nums | std::ranges::views::<span class="built_in">drop</span>(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;take(3): &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : take3) std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出：1 2 3</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\ndrop(2): &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : drop2) std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出：3 4 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h3 id="拼接视图viewsconcat">4. 拼接视图：views::concat</h3>
<p>功能：将多个同类型的范围拼接成一个视图（惰性拼接，不产生中间拷贝）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ranges&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">// 拼接 a 和 b</span></span><br><span class="line">    <span class="keyword">auto</span> combined = std::ranges::views::<span class="built_in">concat</span>(a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : combined) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出：1 2 3 4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h3 id="生成视图viewsiota">5. 生成视图：views::iota</h3>
<p>功能：生成一个无限递增的整数序列（惰性生成，只有遍历到的元素才会被计算），通常与
<code>views::take</code> 配合使用以限制长度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ranges&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生成 1~5 的序列（从 1 开始，取 5 个元素）</span></span><br><span class="line">    <span class="keyword">auto</span> seq = std::ranges::views::<span class="built_in">iota</span>(<span class="number">1</span>) | std::ranges::views::<span class="built_in">take</span>(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : seq) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出：1 2 3 4 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>这里我写的作业是22年的，所以题目可能会有一点点不一样，部分assignment答案我都给出了，没给出的是希望大家可以自己去研究一下的（应该不是我懒了）</p>
<h1 id="assignment1">assignment1</h1>
<p>在看课程的时候，可能会学到<code>istringstream</code>跟<code>ostringstream</code>，会发现这个东西十分精妙，然后我就跃跃欲试去写了<code>assignment1</code>结果发现，我还是大意了。写的时候还是出现了很多问题，在下面一一列举。</p>
<p>1.<code>ostringstream</code>写入文件跟<code>ofstream</code>写入文件是不一样的（<code>ifstream</code>同理），<code>ostringstream</code>的输出目标是内存的缓冲区，不是硬盘文件，所以它没有往文件写入数据的功能;<code>ofstream</code>的输出目标才是文件，天然支持文件的写入功能。简单来说，你如果要把数据写入文件，只能用<code>ofstream</code>。</p>
<p>2.大家应该都会用<code>find</code>的吧，就是<code>string</code>的库的那个，这一章节只要看懂了<strong>流</strong>的操作，那么这一章就没什么问题了。</p>
<p>以下附上我的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Course</span> &#123;</span><br><span class="line">  std::string title;</span><br><span class="line">  std::string number_of_units;</span><br><span class="line">  std::string quarter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">parse_csv</span><span class="params">(std::string filename, std::vector&lt;Course&gt; &amp;courses)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::ifstream <span class="title">iss</span><span class="params">(filename)</span></span>;</span><br><span class="line">  std::string str;</span><br><span class="line">  <span class="built_in">getline</span>(iss, str);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">getline</span>(iss, str)) &#123;</span><br><span class="line">    <span class="keyword">auto</span> temp = <span class="built_in">split</span>(str, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    courses.<span class="built_in">push_back</span>(&#123;temp[<span class="number">0</span>], temp[<span class="number">1</span>], temp[<span class="number">2</span>]&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_courses_offered</span><span class="params">(std::vector&lt;Course&gt; all_courses)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::ofstream <span class="title">oss</span><span class="params">(<span class="string">&quot;student_output/courses_offered.csv&quot;</span>)</span></span>;</span><br><span class="line">  oss &lt;&lt; <span class="string">&quot;Title,Number of Units,Quarter\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> p : all_courses) &#123;</span><br><span class="line">    <span class="keyword">if</span>(p.quarter.<span class="built_in">find</span>(<span class="string">&quot;2023-2024&quot;</span>) != <span class="number">-1</span>) oss &lt;&lt; p &lt;&lt; <span class="string">&quot;\n&quot;</span>;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_courses_not_offered</span><span class="params">(std::vector&lt;Course&gt; unlisted_courses)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::ofstream <span class="title">oss</span><span class="params">(<span class="string">&quot;student_output/courses_not_offered.csv&quot;</span>)</span></span>;</span><br><span class="line">  oss &lt;&lt; <span class="string">&quot;Title,Number of Units,Quarter\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> p : unlisted_courses) &#123;</span><br><span class="line">    <span class="keyword">if</span>(p.quarter.<span class="built_in">find</span>(<span class="string">&quot;2023-2024&quot;</span>) == <span class="number">-1</span>) oss &lt;&lt; p &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果你这么写你是对不了的，还有一些小问题，还是要去自己找找的，推荐去看看<code>utils.cpp</code>的代码。</p>
<h1 id="assignment2">assignment2</h1>
<p>它还是跟流有关的作业，如果课程已经完全听懂了，那么这章并不难。
这一章需要注意的是，如果你想用<code>istringstream</code>的话，必须要头文件<code>sstream</code>。</p>
<p>直接上奋吧</p>
<h2 id="part1">Part1</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::set&lt;std::string&gt; <span class="title">get_applicants</span><span class="params">(std::string filename)</span> </span>&#123;</span><br><span class="line">  std::set&lt;std::string&gt; applicant;</span><br><span class="line">  <span class="function">std::ifstream <span class="title">iss</span><span class="params">(filename)</span></span>;</span><br><span class="line"></span><br><span class="line">  std::string str;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">getline</span>(iss, str)) &#123;</span><br><span class="line">    applicant.<span class="built_in">insert</span>(str);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> applicant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="part2">Part2</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这一段要求是，找出students中，名字首字母之和=kYourName的名字首字母之和。</span></span><br><span class="line"><span class="function">std::queue&lt;<span class="type">const</span> std::string*&gt; <span class="title">find_matches</span><span class="params">(std::string name, std::set&lt;std::string&gt;&amp; students)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::istringstream <span class="title">mch</span><span class="params">(name)</span></span>;</span><br><span class="line">  std::string mtch = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  std::queue&lt;<span class="type">const</span> std::string*&gt; ans;</span><br><span class="line"></span><br><span class="line">  std::string temp;</span><br><span class="line">  <span class="keyword">while</span>(mch &gt;&gt; temp) &#123;</span><br><span class="line">    mtch += temp[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;stu : students) &#123;</span><br><span class="line">    mch.<span class="built_in">str</span>(stu);</span><br><span class="line">    std::string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(mch &gt;&gt; temp) &#123;</span><br><span class="line">      s += temp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s == mtch) &#123;</span><br><span class="line">      ans.<span class="built_in">push</span>(&amp;stu);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一个很神奇的写法，用到了很现代的东西，可以先做了解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">std::string get_initials(const std::string &amp;text) &#123;</span><br><span class="line">  auto combined_initials = text</span><br><span class="line">                           | std::views::split(&#x27; &#x27;)</span><br><span class="line">                           | std::views::filter([](auto&amp;&amp; word) &#123; return !word.empty(); &#125;)</span><br><span class="line">                           | std::views::transform([](auto&amp;&amp; word) &#123; return *word.begin(); &#125;);</span><br><span class="line">  return std::string(combined_initials.begin(), combined_initials.end());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::queue&lt;const std::string*&gt; find_matches(std::string name, std::set&lt;std::string&gt;&amp; students) &#123;</span><br><span class="line">  std::queue&lt;const std::string*&gt; matches;</span><br><span class="line">  std::string given_initials = get_initials(name);</span><br><span class="line">  for (const auto &amp;stu : students) &#123;</span><br><span class="line">    if (get_initials(stu) == given_initials) &#123;</span><br><span class="line">      matches.push(&amp;stu);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return matches;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="part3">Part3</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">get_match</span><span class="params">(std::queue&lt;<span class="type">const</span> std::string*&gt;&amp; matches)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::istringstream <span class="title">mch</span><span class="params">(kYourName)</span></span>;</span><br><span class="line">  std::string mtch = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  std::string temp;</span><br><span class="line">  <span class="keyword">while</span>(mch &gt;&gt; temp) &#123;</span><br><span class="line">    mtch += temp[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!matches.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    std::string stu = *matches.<span class="built_in">front</span>();</span><br><span class="line">    mch.<span class="built_in">str</span>(stu);</span><br><span class="line">    std::string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(mch &gt;&gt; temp) &#123;</span><br><span class="line">      s += temp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s == mtch) &#123;</span><br><span class="line">      <span class="keyword">return</span> stu;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;NO MATCHES FOUND.&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="assignment3">assignment3</h1>
<p>这是一个很简单的作业，就是写一个类需要包含私有的函数，get函数，set函数，构造函数，没有传参的构造函数。
很推荐大家尝试把 <code>class.h</code> 跟 <code>class.cpp</code>
分开来写</p>
<p>但是有个关键点是，运行代码的时候要执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++23 main.cpp class.cpp -o main</span><br></pre></td></tr></table></figure>
<h1 id="assignment4">assignment4</h1>
<p>很明显的可以感觉到这个作业已经开始上强度了，很多东西可以用<code>C++</code>新一点的函数来写比如，这个作业里面用到的，<code>std::ranges::views</code></p>
<h2 id="作业要求part1">作业要求Part1</h2>
<p>完成 <code>tokenize</code> 这个分词函数，将 <code>source</code>
这个长字符串分割成一系列的 <code>Token</code>，代码中不能使用任何
<code>for/while</code> 循环，使用传统的 <code>STL</code>。 该
<code>part</code> 有三个小任务：1.识别所有指向空格字符的迭代器
2.在连诉的空格字符之间生成词元 3.去除空词元</p>
<h2 id="作业要求part2">作业要求Part2</h2>
<p>完成 <code>spellcheck</code> 函数，识别拼写错误并给出拼写建议
，需要使用全新的 <code>ranges</code> 库。 该 <code>part</code>
有三个小任务：1.跳过已经拼写正确的单词 2.对拼写不正确的单词，用
<code>levenshtein</code>函数来查找范围值为1的单词
3.经过处理后丢弃没有建议的拼写错误。</p>
<p>希望大家先看上面的要求再写lab，因为我之前直接写，没看懂要求。</p>
<p>好了大家先学 <code>ranges</code> 库的东西，再来写这个作业。</p>
<h2 id="part1-1">Part1</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Corpus <span class="title">tokenize</span><span class="params">(std::string&amp; source)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//todo</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> space = <span class="built_in">find_all</span>(source.<span class="built_in">begin</span>(), source.<span class="built_in">end</span>(), isspace);</span><br><span class="line">  Corpus tokens;</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">transform</span>(space.<span class="built_in">begin</span>(), space.<span class="built_in">end</span>() - <span class="number">1</span>, space.<span class="built_in">begin</span>() + <span class="number">1</span>, </span><br><span class="line">    std::<span class="built_in">inserter</span>(tokens, tokens.<span class="built_in">end</span>()), </span><br><span class="line">    [&amp;source](<span class="keyword">auto</span> &amp;&amp;_first1, <span class="keyword">auto</span> &amp;&amp;_first2) &#123;</span><br><span class="line">      <span class="keyword">return</span> Token&#123;source, _first1, _first2&#125;;</span><br><span class="line">  &#125;); </span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">erase_if</span>(tokens, [](<span class="type">const</span> Token &amp;token) &#123; <span class="keyword">return</span> token.content.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">  <span class="keyword">return</span> tokens;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="part2-1">Part2</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::set&lt;Misspelling&gt; <span class="title">spellcheck</span><span class="params">(<span class="type">const</span> Corpus&amp; source, <span class="type">const</span> Dictionary&amp; dictionary)</span> </span>&#123;  </span><br><span class="line">  <span class="comment">//todo</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">auto</span> view = source </span><br><span class="line">    | std::ranges::views::<span class="built_in">filter</span>([&amp;dictionary](<span class="type">const</span> Token &amp;token) &#123;</span><br><span class="line">        <span class="keyword">return</span> !dictionary.<span class="built_in">contains</span>(token.content);</span><br><span class="line">      &#125;) </span><br><span class="line">    | std::ranges::views::<span class="built_in">transform</span>([&amp;dictionary](<span class="type">const</span> Token &amp;token) -&gt; Misspelling &#123;</span><br><span class="line">        <span class="keyword">auto</span> dview = dictionary </span><br><span class="line">          | std::ranges::views::<span class="built_in">filter</span>([&amp;token](<span class="type">const</span> std::string &amp;str) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">levenshtein</span>(token.content, str);</span><br><span class="line">          &#125;);</span><br><span class="line">        std::set&lt;std::string&gt; <span class="built_in">sug</span>(dview.<span class="built_in">begin</span>(), dview.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> Misspelling&#123;token, sug&#125;;</span><br><span class="line">      &#125;)</span><br><span class="line">    | std::ranges::views::<span class="built_in">filter</span>([](<span class="type">const</span> Misspelling &amp;elem) &#123;</span><br><span class="line">      <span class="keyword">return</span> !elem.suggestions.<span class="built_in">empty</span>();</span><br><span class="line">      &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">set</span>&lt;Misspelling&gt;(view.<span class="built_in">begin</span>(), view.<span class="built_in">end</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>多嘴一句，记得编译的时候要用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++23 main.cpp spellcheck.cpp -o main</span><br></pre></td></tr></table></figure>
<h1 id="assignment5">assignment5</h1>
<p>这个作业就是正常的涉及到面向对象中的构造函数，析构函数，以及函数的重载等。</p>
<h2 id="part1-2">Part1</h2>
<p>编写一个<code>operator&lt;&lt;</code>运算符，用于将<code>User</code>对象输出到<code>std::ostream</code>，多一嘴他应该是一个友元函数。输出样例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User(name=Alice, friends=[Bob, Charlie])</span><br></pre></td></tr></table></figure>
<h2 id="part2-2">Part2</h2>
<ol type="1">
<li>为<code>User</code>类实现析构函数。需实现<code>~User()</code>特殊成员函数。</li>
<li>使<code>User</code>类可拷贝构造。需实现<code>User(const User&amp; user)</code>特殊成员函数。</li>
<li>使<code>User</code>类可拷贝赋值。需实现<code>User&amp; operator=(const User&amp; user)</code>特殊成员函数。</li>
<li>禁止<code>User</code>类可移动构造。需删除<code>User(User&amp;&amp; user)</code>特殊成员函数。</li>
<li>禁止<code>User</code>类可移动赋值。需删除<code>User&amp; operator=(User&amp;&amp; user)</code>特殊成员函数。</li>
</ol>
<h2 id="part3-1">Part3</h2>
<p>编写一个<code>operator+=</code>运算符用于表示将一个用户添加到另一个用户的好友列表中。该操作应是对称的，例如，将Charlie添加到Alice的好友列表时，Alice也应被添加到Charlie的好友列表中。示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">User <span class="title">alice</span><span class="params">(<span class="string">&quot;Alice&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">User <span class="title">charlie</span><span class="params">(<span class="string">&quot;Charlie&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">alice += charlie;</span><br><span class="line">std::cout &lt;&lt; alice &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; charlie &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预期输出：</span></span><br><span class="line"><span class="comment">// User(name=Alice, friends=[Charlie])</span></span><br><span class="line"><span class="comment">// User(name=Charlie, friends=[Alice])</span></span><br></pre></td></tr></table></figure>
<h1 id="assignment6">assignment6</h1>
<p>这个作业已经涉及到一点现代C++的知识了，他要求我们用
<code>optional</code> 这是 C++17
引入的非常有用的类型，它表示一个<strong>可能包含值也可能不包含值</strong>的对象。
在写本次作业前，希望大家可以先学一下 <code>optional</code>
的相关知识。</p>
<h3 id="为什么需要-optional">为什么需要 <code>optional</code>？</h3>
<p>在没有 <code>optional</code>
之前，我们通常使用特殊值来表示”无值”状态：</p>
<ul>
<li>指针：<code>nullptr</code></li>
<li>整数：<code>-1</code>、<code>0</code> 等魔法数字</li>
<li>布尔值 + 实际值 的组合</li>
</ul>
<p>这些方法都不够类型安全且容易出错。</p>
<p>例如，我们应该怎么样使用 <code>optional</code> 里面的东西呢。</p>
<h2 id="创建-optional-对象">1.创建 <code>optional</code> 对象</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 空 optional</span><br><span class="line">std::optional&lt;int&gt; empty_opt;</span><br><span class="line">std::optional&lt;int&gt; empty_opt2 = std::nullopt;  // 显式为空</span><br><span class="line"></span><br><span class="line">// 包含值的 optional</span><br><span class="line">std::optional&lt;int&gt; opt1(42);</span><br><span class="line">std::optional&lt;int&gt; opt2 = 42;</span><br><span class="line">auto opt3 = std::make_optional(42);  // 自动推导类型</span><br><span class="line"></span><br><span class="line">// 原地构造</span><br><span class="line">std::optional&lt;std::string&gt; opt4(std::in_place, &quot;Hello&quot;, 5);  // 构造 std::string(&quot;Hello&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="检查是否包含值">2.检查是否包含值</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">std::optional&lt;int&gt; opt = get_value();</span><br><span class="line"></span><br><span class="line">// 方法1: has_value()</span><br><span class="line">if (opt.has_value()) &#123;</span><br><span class="line">    // 有值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方法2: 转换为 bool</span><br><span class="line">if (opt) &#123;</span><br><span class="line">    // 有值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方法3: value_or() - 有值时返回值，无值时返回默认值</span><br><span class="line">// 没记错的话，这个应该是C++23引入的</span><br><span class="line">int value = opt.value_or(-1);  // 如果opt为空，返回-1</span><br></pre></td></tr></table></figure>
<h2 id="各种操作">3.各种操作</h2>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="header">
<th>操作</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>std::nullopt</code></td>
<td>表示空的<code>optional</code>，用于赋值或返回空值</td>
</tr>
<tr class="even">
<td><code>has_value()</code></td>
<td>检查<code>optional</code>是否包含值，返回<code>bool</code></td>
</tr>
<tr class="odd">
<td><code>value()</code></td>
<td>获取值，无值时抛出<code>std::bad_optional_access</code>异常（慎用）</td>
</tr>
<tr class="even">
<td><code>value_or(默认值)</code></td>
<td>安全获取值：有值则返回值，无值则返回传入的默认值（推荐日常使用）</td>
</tr>
<tr class="odd">
<td><code>operator*</code>/<code>-&gt;</code></td>
<td>解引用获取值（类似指针），需先确认有值，否则行为未定义</td>
</tr>
<tr class="even">
<td><code>reset()</code></td>
<td>清空<code>optional</code>的值，使其变为空</td>
</tr>
<tr class="odd">
<td><code>std::make_optional</code></td>
<td>显式构造<code>optional</code>对象，支持类型推导，比直接构造更简洁（推荐）</td>
</tr>
</tbody>
</table>
<h3 id="transform-1">(1) transform</h3>
<h4 id="核心作用">核心作用</h4>
<p>如果当前<code>optional</code>包含值，就对这个值应用你传入的转换函数，返回一个<strong>新的
optional</strong>（类型由转换函数的返回值决定）；如果当前<code>optional</code>为空，直接返回空的<code>optional</code>（类型和转换后的一致）。</p>
<p>简单说：<code>transform</code>是 “有值就加工，没值就摆烂”。</p>
<h3 id="or_else">(2) or_else</h3>
<h4 id="核心作用-1">核心作用</h4>
<p>如果当前<code>optional</code>为空，就执行你传入的备选函数（该函数返回一个同类型的<code>optional</code>），并返回这个备选结果；如果当前<code>optional</code>有值，直接返回原<code>optional</code>（不会执行备选函数）。</p>
<p>简单说：<code>or_else</code>是 “没值就找备胎，有值就用自己”。</p>
<h3 id="transform-or_else-组合使用实战场景">(3) transform + or_else
组合使用（实战场景）</h3>
<p>这两个函数结合使用时，能实现 “有值就转换，无值就兜底”
的完整逻辑，替代多层 if-else：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟：从配置文件读取端口（可能读取失败，返回空）</span></span><br><span class="line"><span class="function">std::optional&lt;<span class="type">int</span>&gt; <span class="title">read_port_from_config</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟读取失败</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟：获取默认端口</span></span><br><span class="line"><span class="function">std::optional&lt;<span class="type">int</span>&gt; <span class="title">get_default_port</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;使用默认端口&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">8080</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换：端口转成连接字符串</span></span><br><span class="line"><span class="function">std::string <span class="title">port_to_conn_str</span><span class="params">(<span class="type">int</span> port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;连接地址：localhost:&quot;</span> + std::<span class="built_in">to_string</span>(port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑：读取端口 → 无值则用默认 → 有值则转成连接字符串</span></span><br><span class="line">    <span class="keyword">auto</span> conn_str = <span class="built_in">read_port_from_config</span>()          <span class="comment">// 空的optional&lt;int&gt;</span></span><br><span class="line">        .<span class="built_in">or_else</span>(get_default_port)                   <span class="comment">// 无值，执行备选，返回optional&lt;int&gt;(8080)</span></span><br><span class="line">        .<span class="built_in">transform</span>(port_to_conn_str);                <span class="comment">// 有值，转换为optional&lt;string&gt;</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; conn_str.<span class="built_in">value</span>() &lt;&lt; std::endl;      <span class="comment">// 输出：连接地址：localhost:8080</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="part1-3">Part1</h2>
<p>完成 <code>find_course</code> 函数</p>
<h2 id="part2-3">Part2</h2>
<p>完成下面对 <code>output</code> 的转换。</p>
<ul>
<li><p>如果找到课程，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Found course: &lt;课程名称&gt;,&lt;学分&gt;,&lt;开课季度&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>如果未找到课程，则上述代码应输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Course not found.</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="assignment7">assignment7</h1>
<p>这次作业主要是看大家对于智能指针的了解，实现类似于
<code>unique_ptr</code>
的功能的复现，但是没有很全面的用到智能指针的相关内容，大家可以课后找个例子再多学一下智能指针的相关知识。</p>
<h3 id="一为什么需要智能指针">一、为什么需要智能指针？</h3>
<p>首先要明确：<strong>智能指针的核心目的是解决手动管理动态内存的痛点</strong>。C++
中用<code>new</code>分配的堆内存，必须用<code>delete</code>手动释放，新手很容易踩坑：</p>
<ul>
<li>忘记<code>delete</code> → 内存泄漏；</li>
<li>重复<code>delete</code> → 未定义行为（程序崩溃）；</li>
<li>析构前抛出异常 → 内存泄漏；</li>
<li>多个指针指向同一块内存，析构时互相干扰（比如你作业里<code>unique_ptr</code>拷贝的问题）。</li>
</ul>
<p>智能指针是<strong>封装了原生指针的模板类</strong>，遵循<strong>RAII（资源获取即初始化）</strong>
原则：</p>
<ul>
<li>当智能指针对象<strong>创建</strong>时，获取内存资源；</li>
<li>当智能指针对象<strong>超出作用域 /
析构</strong>时，自动释放内存（无需手动<code>delete</code>）；</li>
<li>语义清晰，明确内存的 “所有权”（谁负责释放）。</li>
</ul>
<h3 id="二c-核心智能指针类型">二、C++ 核心智能指针类型</h3>
<p>C++11
及以后标准库提供了三种核心智能指针（都在<code>&lt;memory&gt;</code>头文件中），其中你作业实现的<code>unique_ptr</code>是最基础、最常用的。</p>
<h4 id="unique_ptr独占智能指针">1. unique_ptr（独占智能指针）</h4>
<h5 id="核心特点">核心特点</h5>
<ul>
<li><strong>独占所有权</strong>：同一时间，只有一个<code>unique_ptr</code>能指向同一块内存；</li>
<li><strong>不支持拷贝</strong>：禁用了拷贝构造 /
拷贝赋值运算符（你作业里需要删除这两个函数）；</li>
<li><strong>支持移动</strong>：可以通过<code>std::move()</code>转移所有权（转移后原指针变为<code>nullptr</code>）；</li>
<li><strong>开销极小</strong>：几乎和原生指针一样快，无额外内存开销；</li>
<li><strong>析构时自动释放</strong>：超出作用域时调用<code>delete</code>释放内存。</li>
</ul>
<h5 id="基础用法示例">基础用法示例</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建unique_ptr（优先用make_unique，C++14起支持）</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr1 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 等价于：std::unique_ptr&lt;int&gt; ptr1(new int(10));（不推荐，易漏释放）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 访问数据（和原生指针一样）</span></span><br><span class="line">    std::cout &lt;&lt; *ptr1 &lt;&lt; std::endl; <span class="comment">// 输出10</span></span><br><span class="line">    std::cout &lt;&lt; ptr1-&gt;<span class="keyword">operator</span>*() &lt;&lt; std::endl; <span class="comment">// 等价写法（作业里实现的operator*）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 移动所有权（不能直接拷贝，必须用std::move）</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = std::<span class="built_in">move</span>(ptr1); </span><br><span class="line">    <span class="comment">// 此时ptr1 == nullptr，ptr2指向值为10的内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 重置指针（手动释放/更换指向）</span></span><br><span class="line">    ptr<span class="number">2.</span><span class="built_in">reset</span>(); <span class="comment">// 释放内存，ptr2变为nullptr</span></span><br><span class="line">    ptr<span class="number">2.</span><span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>)); <span class="comment">// 指向新的内存（值为20）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// ptr2超出作用域，自动释放内存（调用delete）</span></span><br></pre></td></tr></table></figure>
<h5 id="适用场景">适用场景</h5>
<ul>
<li>单个对象 / 资源的独占管理（比如你作业里的链表节点）；</li>
<li>函数返回动态分配的对象（避免返回原生指针导致内存泄漏）；</li>
<li>容器中存储独占对象（<code>std::vector&lt;std::unique_ptr&lt;T&gt;&gt;</code>）。</li>
</ul>
<h4 id="shared_ptr共享智能指针">2. shared_ptr（共享智能指针）</h4>
<h5 id="核心特点-1">核心特点</h5>
<ul>
<li><p><strong>共享所有权</strong>：多个<code>shared_ptr</code>可以指向同一块内存；</p></li>
<li><p>引用计数</p>
<p>：内部维护一个 “引用计数器”（堆上的整数）：</p>
<ul>
<li>拷贝<code>shared_ptr</code> → 计数 + 1；</li>
<li>析构 / 重置<code>shared_ptr</code> → 计数 - 1；</li>
<li>当计数为 0 时，自动释放内存；</li>
</ul></li>
<li><p><strong>支持拷贝 /
移动</strong>：拷贝会增加计数，移动不改变计数；</p></li>
<li><p><strong>开销略大</strong>：需要维护引用计数（原子操作，线程安全）。</p></li>
</ul>
<h5 id="基础用法示例-1">基础用法示例</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建shared_ptr（优先用make_shared，更高效）</span></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 拷贝：引用计数+1（此时计数=2）</span></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;引用计数：&quot;</span> &lt;&lt; ptr<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 输出2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 访问数据（和unique_ptr一致）</span></span><br><span class="line">    *ptr2 = <span class="number">200</span>;</span><br><span class="line">    std::cout &lt;&lt; *ptr1 &lt;&lt; std::endl; <span class="comment">// 输出200（共享同一块内存）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 重置：计数-1（ptr1变为nullptr，计数=1）</span></span><br><span class="line">    ptr<span class="number">1.</span><span class="built_in">reset</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;引用计数：&quot;</span> &lt;&lt; ptr<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 输出1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// ptr2超出作用域，计数-1=0，释放内存</span></span><br></pre></td></tr></table></figure>
<h5 id="注意循环引用问题">注意：循环引用问题</h5>
<p><code>shared_ptr</code>的最大坑是<strong>循环引用</strong>：两个<code>shared_ptr</code>互相指向，导致引用计数永远不为
0，内存泄漏。比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; next; <span class="comment">// 互相指向，计数永远为1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> n1 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">auto</span> n2 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line">    n1-&gt;next = n2;</span><br><span class="line">    n2-&gt;next = n1;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 析构时n1和n2的计数都是1，内存泄漏！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="weak_ptr弱引用智能指针">3. weak_ptr（弱引用智能指针）</h4>
<h5 id="核心特点-2">核心特点</h5>
<ul>
<li><strong>弱引用</strong>：指向<code>shared_ptr</code>管理的内存，但<strong>不拥有所有权</strong>；</li>
<li><strong>不增加引用计数</strong>：不会影响内存的释放；</li>
<li><strong>需要 lock ()
才能访问</strong>：<code>lock()</code>会返回一个<code>shared_ptr</code>（若内存已释放，返回空）；</li>
<li><strong>核心作用</strong>：解决<code>shared_ptr</code>的循环引用问题。</li>
</ul>
<h5 id="解决循环引用的示例">解决循环引用的示例</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::weak_ptr&lt;Node&gt; next; <span class="comment">// 改用weak_ptr，不增加计数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> n1 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">auto</span> n2 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line">    n1-&gt;next = n2;</span><br><span class="line">    n2-&gt;next = n1;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 析构时计数=0，内存正常释放！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好吧其实我有点懒了，大家可以看一下一下的内容跟 <code>README.md</code>
的内容一致，只是翻译了一下。</p>
<h2 id="本章作业任务">本章作业任务</h2>
<ol type="1">
<li><code>unique_ptr</code>类的私有成员部分</li>
<li>构造函数 <code>unique_ptr(T* ptr)</code></li>
<li>支持空指针的构造函数 <code>unique_ptr(std::nullptr_t)</code></li>
<li>解引用运算符 <code>T&amp; operator*()</code></li>
<li>常量版本的解引用运算符
<code>const T&amp; operator*() const</code></li>
<li>成员访问运算符 <code>T* operator-&gt;()</code></li>
<li>常量版本的成员访问运算符
<code>const T* operator-&gt;() const</code></li>
<li>布尔类型转换运算符 <code>operator bool() const</code></li>
</ol>
<p>但另一方面，我们<strong>仍然需要支持<code>unique_ptr</code>的移动操作</strong>。回顾移动语义的知识点：移动操作可以让我们获取一个对象的资源所有权，且不需要进行昂贵的拷贝操作。移动<code>unique_ptr</code>是合法的，因为这能保证指针的
“独占性”—— 任何时刻，始终只有一个指针指向底层内存，我们只是改变了
“谁（哪个变量）拥有这块内存”。</p>
<p>为了实现以下三个核心目标
——<strong>自动释放内存</strong>、<strong>禁止拷贝</strong>、<strong>支持移动</strong>，你需要为<code>unique_ptr</code>类实现一组<strong>特殊成员函数</strong>。具体来说，需要实现以下函数：</p>
<ol type="1">
<li><code>~unique_ptr()</code>：析构函数，释放指针指向的内存</li>
<li><code>unique_ptr(const unique_ptr&amp; other)</code>：拷贝构造函数，<strong>需要将其禁用</strong></li>
<li><code>unique_ptr&amp; operator=(const unique_ptr&amp; other)</code>：拷贝赋值运算符，<strong>需要将其禁用</strong></li>
<li><code>unique_ptr(unique_ptr&amp;&amp; other)</code>：移动构造函数</li>
<li><code>unique_ptr&amp; operator=(unique_ptr&amp;&amp; other)</code>：移动赋值运算符</li>
</ol>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>fanan
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://blog.wustacm.org/2025/12/28/2022CS106L%E9%A1%BB%E7%9F%A5/" title="2022CS106L须知">http://blog.wustacm.org/2025/12/28/2022CS106L须知/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="https://wustacm.scandidreams.top/wiki/">
            <span class="icon">
              <i class="fab fa-wiki"></i>
            </span>

            <span class="label">wiki</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/cs106l/" rel="tag"><i class="fa fa-tag"></i> cs106l</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/12/24/Codeforces%20Round%201071%20(Div.%203)%20%E9%A2%98%E8%A7%A3/" rel="prev" title="Codeforces Round 1071 (Div. 3) 题解">
      <i class="fa fa-chevron-left"></i> Codeforces Round 1071 (Div. 3) 题解
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/12/30/CF2182(Educational%20Codeforces%20Round%20186)%E9%A2%98%E8%A7%A3/" rel="next" title="CF2182(Educational Codeforces Round 186)题解">
      CF2182(Educational Codeforces Round 186)题解 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#cs106l%E9%A1%BB%E7%9F%A5"><span class="nav-number">1.</span> <span class="nav-text">CS106L须知</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8Ecs106b%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.1.</span> <span class="nav-text">与CS106B的关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8cs106l%E4%B8%AD%E4%BC%9A%E5%AD%A6%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86"><span class="nav-number">2.</span> <span class="nav-text">在CS106L中会学到的一些知识</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#auto%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">auto的类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#algorithm"><span class="nav-number">4.</span> <span class="nav-text">algorithm</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#stdsort"><span class="nav-number">4.1.</span> <span class="nav-text">(1) std::sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stdnth_element"><span class="nav-number">4.2.</span> <span class="nav-text">(2) std::nth_element</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stdstable_partition"><span class="nav-number">4.3.</span> <span class="nav-text">(3) std::stable_partition</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stdcopy_if"><span class="nav-number">4.4.</span> <span class="nav-text">(4) std::copy_if</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stdremove_if"><span class="nav-number">4.5.</span> <span class="nav-text">(5) std::remove_if</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#transform"><span class="nav-number">4.6.</span> <span class="nav-text">(6) transform</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ranges"><span class="nav-number">5.</span> <span class="nav-text">ranges</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%BD%8D"><span class="nav-number">5.1.</span> <span class="nav-text">一、定义与核心定位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="nav-number">5.2.</span> <span class="nav-text">二、核心特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BClazy-evaluation"><span class="nav-number">5.2.1.</span> <span class="nav-text">1. 惰性求值（Lazy Evaluation）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E5%AD%98%E5%82%A8%E8%BD%BB%E9%87%8F%E7%BA%A7"><span class="nav-number">5.2.2.</span> <span class="nav-text">2. 无存储、轻量级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E4%BF%AE%E6%94%B9%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE"><span class="nav-number">5.2.3.</span> <span class="nav-text">3. 不可修改原始数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E7%BB%84%E5%90%88%E6%80%A7composability"><span class="nav-number">5.2.4.</span> <span class="nav-text">4. 可组合性（Composability）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%BC%E5%AE%B9%E6%A0%87%E5%87%86%E7%AE%97%E6%B3%95"><span class="nav-number">5.2.5.</span> <span class="nav-text">5. 兼容标准算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E5%B8%B8%E8%A7%81%E8%A7%86%E5%9B%BE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-number">5.3.</span> <span class="nav-text">三、常见视图类型及使用示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E8%A7%86%E5%9B%BEviewsfilter"><span class="nav-number">5.3.1.</span> <span class="nav-text">1. 过滤视图：views::filter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E8%A7%86%E5%9B%BEviewstransform"><span class="nav-number">5.3.2.</span> <span class="nav-text">2. 转换视图：views::transform</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E7%89%87%E8%A7%86%E5%9B%BEviewstake-%E4%B8%8E-viewsdrop"><span class="nav-number">5.3.3.</span> <span class="nav-text">3. 切片视图：views::take 与
views::drop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%BC%E6%8E%A5%E8%A7%86%E5%9B%BEviewsconcat"><span class="nav-number">5.3.4.</span> <span class="nav-text">4. 拼接视图：views::concat</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E8%A7%86%E5%9B%BEviewsiota"><span class="nav-number">5.3.5.</span> <span class="nav-text">5. 生成视图：views::iota</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#assignment1"><span class="nav-number">6.</span> <span class="nav-text">assignment1</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#assignment2"><span class="nav-number">7.</span> <span class="nav-text">assignment2</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#part1"><span class="nav-number">7.1.</span> <span class="nav-text">Part1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#part2"><span class="nav-number">7.2.</span> <span class="nav-text">Part2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#part3"><span class="nav-number">7.3.</span> <span class="nav-text">Part3</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#assignment3"><span class="nav-number">8.</span> <span class="nav-text">assignment3</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#assignment4"><span class="nav-number">9.</span> <span class="nav-text">assignment4</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%9C%E4%B8%9A%E8%A6%81%E6%B1%82part1"><span class="nav-number">9.1.</span> <span class="nav-text">作业要求Part1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%9C%E4%B8%9A%E8%A6%81%E6%B1%82part2"><span class="nav-number">9.2.</span> <span class="nav-text">作业要求Part2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#part1-1"><span class="nav-number">9.3.</span> <span class="nav-text">Part1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#part2-1"><span class="nav-number">9.4.</span> <span class="nav-text">Part2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#assignment5"><span class="nav-number">10.</span> <span class="nav-text">assignment5</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#part1-2"><span class="nav-number">10.1.</span> <span class="nav-text">Part1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#part2-2"><span class="nav-number">10.2.</span> <span class="nav-text">Part2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#part3-1"><span class="nav-number">10.3.</span> <span class="nav-text">Part3</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#assignment6"><span class="nav-number">11.</span> <span class="nav-text">assignment6</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-optional"><span class="nav-number">11.1.</span> <span class="nav-text">为什么需要 optional？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-optional-%E5%AF%B9%E8%B1%A1"><span class="nav-number">11.2.</span> <span class="nav-text">1.创建 optional 对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E5%80%BC"><span class="nav-number">11.3.</span> <span class="nav-text">2.检查是否包含值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%84%E7%A7%8D%E6%93%8D%E4%BD%9C"><span class="nav-number">11.4.</span> <span class="nav-text">3.各种操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#transform-1"><span class="nav-number">11.4.1.</span> <span class="nav-text">(1) transform</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E4%BD%9C%E7%94%A8"><span class="nav-number">11.4.1.1.</span> <span class="nav-text">核心作用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#or_else"><span class="nav-number">11.4.2.</span> <span class="nav-text">(2) or_else</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E4%BD%9C%E7%94%A8-1"><span class="nav-number">11.4.2.1.</span> <span class="nav-text">核心作用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#transform-or_else-%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8%E5%AE%9E%E6%88%98%E5%9C%BA%E6%99%AF"><span class="nav-number">11.4.3.</span> <span class="nav-text">(3) transform + or_else
组合使用（实战场景）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#part1-3"><span class="nav-number">11.5.</span> <span class="nav-text">Part1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#part2-3"><span class="nav-number">11.6.</span> <span class="nav-text">Part2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#assignment7"><span class="nav-number">12.</span> <span class="nav-text">assignment7</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">12.1.</span> <span class="nav-text">一、为什么需要智能指针？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8Cc-%E6%A0%B8%E5%BF%83%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B"><span class="nav-number">12.2.</span> <span class="nav-text">二、C++ 核心智能指针类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#unique_ptr%E7%8B%AC%E5%8D%A0%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">12.2.1.</span> <span class="nav-text">1. unique_ptr（独占智能指针）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E7%82%B9"><span class="nav-number">12.2.1.1.</span> <span class="nav-text">核心特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="nav-number">12.2.1.2.</span> <span class="nav-text">基础用法示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">12.2.1.3.</span> <span class="nav-text">适用场景</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shared_ptr%E5%85%B1%E4%BA%AB%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">12.2.2.</span> <span class="nav-text">2. shared_ptr（共享智能指针）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E7%82%B9-1"><span class="nav-number">12.2.2.1.</span> <span class="nav-text">核心特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">12.2.2.2.</span> <span class="nav-text">基础用法示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98"><span class="nav-number">12.2.2.3.</span> <span class="nav-text">注意：循环引用问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#weak_ptr%E5%BC%B1%E5%BC%95%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">12.2.3.</span> <span class="nav-text">3. weak_ptr（弱引用智能指针）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E7%82%B9-2"><span class="nav-number">12.2.3.1.</span> <span class="nav-text">核心特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="nav-number">12.2.3.2.</span> <span class="nav-text">解决循环引用的示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E4%BD%9C%E4%B8%9A%E4%BB%BB%E5%8A%A1"><span class="nav-number">12.3.</span> <span class="nav-text">本章作业任务</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Blog</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1dVU1RBQ00vYmxvZy5naXRodWIuaW8=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;WUSTACM&#x2F;blog.github.io"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly93dXN0YWNtLnNjYW5kaWRyZWFtcy50b3Avd2lraS8=" title="wiki → https:&#x2F;&#x2F;wustacm.scandidreams.top&#x2F;wiki&#x2F;"><i class="fab fa-bilibili fa-fw"></i>wiki</span>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="languages">
    <label class="lang-select-label">
      <i class="fa fa-language"></i>
      <span>简体中文</span>
      <i class="fa fa-angle-up" aria-hidden="true"></i>
    </label>
    <select class="lang-select" data-canonical="">
      
        <option value="zh-CN" data-href="/2025/12/28/2022CS106L%E9%A1%BB%E7%9F%A5/" selected="">
          简体中文
        </option>
      
        <option value="en" data-href="/en/2025/12/28/2022CS106L%E9%A1%BB%E7%9F%A5/" selected="">
          English
        </option>
      
    </select>
  </div>

        

<div class="copyright">
  
  &copy; 2025 – 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Blog</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">76k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:36</span>
</div>
  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0Lm9yZw==">NexT.Gemini</span> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'QCMzzxhYIC5ZhGjunFmzzGNs-gzGzoHsz',
      appKey     : 'mrUydHkXNGvacgPVL5OoK8UC',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-CN' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

    </div>
</body>
</html>
