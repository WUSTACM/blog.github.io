---
title: 2022CS106L须知
date: 2025-12-28
tags: [cs106l]
categories: [技术分享]

cover: https://i.postimg.cc/ZnCzZKvr/2cb79efe667b08d4b12e3b103d67653.jpg
banner: https://i.postimg.cc/ZnCzZKvr/2cb79efe667b08d4b12e3b103d67653.jpg
topic: 题解
headline: 大标题
caption: 标题下方的小字
color: 标题颜色
mathjax: true
rightbar: toc
description:
poster:
sticky:
mermaid:
katex:
author: fanan
references:
comments:
indexing:
breadcrumb:
leftbar:
h1:
type:

---



# CS106L须知

CS106L非常适合想学习工程化C++的同学，注重标准库（STL）、RAII、智能指针、移动语义等。在其中我们会学到很多现代C++的东西以及基础的类的相关知识，都是一些非常有意思的东西，会让大家眼前焕然一新。

<!-- more -->

### 与CS106B的关系

```
CS106B：编程抽象（C++基础 + 数据结构）
    ↓
CS106L：标准 C++ 编程实验室（深入 C++ 特性）
    ↓
CS106X：编程抽象加速版（更高级）
```



# 在CS106L中会学到的一些知识

智能指针的笔记在后面，仅列出本人学到的知识以及我觉得比较重要的知识。

# auto的类型

````c++
auto multiplier = 2.4;  //double
auto name = "Fanan"; //char* (c-string)
auto bettername = string{"Fanan"}; //string
const auto& bettername1 = string{"Fanan"} //const string&
auto& refMult = multiplier; //double&

auto func = [](auto i) {
    return i * 2;
}; //lambda
````

# algorithm

## (1) std::sort

````C++
// std::sort这个大家或多或少都有接触过的吧
vector<int> num = {1, 2, 3, 4};
sort(num.begin(), num.end(), [](const int& a, const int& b) {
    return a > b;
});
````

## (2) std::nth_element

````c++
/*
给定一个容器（如vector）和一个位置nth，将容器中 “第 n 个元素” 放到完全排序后它应该在的位置；
该位置左侧的所有元素都 ≤ 它（默认升序），右侧的所有元素都 ≥ 它；
左右两侧的元素不保证有序（这是和sort的核心区别），但能保证nth位置的元素是 “正确值”。
复杂度O(n)
*/

std::vector<int> nums = {7, 2, 9, 1, 5, 4, 8, 3, 6};
auto nth_pos = nums.begin() + 2;
std::nth_element(nums.begin(), nth_pos, nums.end());
//nums将会变成 2 1 3 7 5 4 8 9 6（3在正确位置，左右分别≤/≥3）
````

## (3) std::stable_partition

````c++
/*
将容器中的元素按「自定义条件（谓词）」分成两部分：满足条件的元素在前，不满足的在后；
关键特性：两部分内部的元素会保持原有的相对顺序（“stable” 的核心含义）；
对比普通std::partition：后者仅完成分区，但不保证两部分内部的顺序，而stable_partition会保留顺序（代价是时间 / 空间复杂度略高）。
*/
std::vector<int> nums = {7, 2, 9, 4, 5, 8};
auto partition_it = std::stable_partition(nums.begin(), nums.end(), [](int a) {
    return a % 2 == 0;
});

for (auto it = nums.begin(); it != partition_it; ++it) {
    std::cout << *it << " "; // 输出：2 4 8（和原数组中偶数出现的顺序一致）
}

for (auto it = partition_it; it != nums.end(); ++it) {
    std::cout << *it << " "; // 输出：7 9 5（和原数组中奇数出现的顺序一致）
}
````

## (4) std::copy_if

````c++
/* 
从源容器中遍历元素，只将满足自定义条件（谓词） 的元素拷贝到目标容器中；
不修改原容器，仅做 “筛选 + 拷贝”，属于 “非修改型算法”；
对比std::copy：std::copy拷贝所有元素，std::copy_if只拷贝满足条件的元素，灵活性更高。
*/

std::vector<int> src = {1, 2, 3, 4, 5, 6, 7, 8};
// 目标容器（提前为空，用back_inserter自动插入),如果容器不空，他会自动在容器后面添加
std::vector<int> dest;

std::copy_if(src.begin(), src.end(), std::back_inserter(dest), [](int a) {
    return a % 2 == 0;
});

std::cout << "拷贝的偶数：";
for (int num : dest) {
    std::cout << num << " "; // 输出：2 4 6 8
}
````

## (5) std::remove_if

````C++
/*
核心作用：遍历容器，将不满足移除条件的元素向前移动（覆盖），把满足移除条件的元素挤到容器末尾；
关键特性：不实际删除元素，也不改变容器的size()，仅改变元素位置；
返回值：指向容器中 “第一个需要被删除的元素” 的迭代器（即末尾待删除区域的起始位置）；
对比std::copy_if：
	1.copy_if：拷贝满足条件的元素到新容器，不修改原容器；
	2.remove_if：原地移动元素，修改原容器内容，但需配合erase才会真正删除元素。
*/

std::vector<int> nums = {1, 2, 3, 4, 5, 6};
std::cout << nums.size() << std::endl; //输出6

auto it = std::remove_if(nums.begin(), nums.end(), [](int a) {
    return a & 1;
});
std::cout << nums.size() << std::endl; //输出6，顺序为1 3 5 2 4 6

nums.erase(it, nums.end());
std::cout << nums.size() << std::endl; //输出3

//可以连起来写
nums.erase(
	std::remove_if(nums.begin(), nums.end(), 
    	[](int a) {return a & 1;}),
    nums.end()
);
````

## (6) transform

````c++
//如果大家打过算法竞赛的话，应该有接触过一点点，比如
string s = "Fanan";
transform(s.begin(), s.end(), s.begin(), ::tolower);
//这是一个把字符串中所有字符都小写的一个写法，这就是一个典型的transform的一元操作。

template< class InputIt, class OutputIt, class UnaryOperation >
OutputIt transform( InputIt first1, InputIt last1, 
                    OutputIt d_first, UnaryOperation unary_op );
//first1,last1分别是迭代器的头跟尾，d_first是最后写入哪里，unary_op是操作。
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> src = {1, 2, 3, 4, 5};
    std::vector<int> dst(src.size());
    
    // 将每个元素乘以2
    std::transform(src.begin(), src.end(), dst.begin(),
                   [](int x) { return x * 2; });
    
    // 输出：2 4 6 8 10
    for (int x : dst) std::cout << x << " ";
    
    return 0;
}


//transform的二元操作
template< class InputIt1, class InputIt2, class OutputIt, class BinaryOperation >
OutputIt transform( InputIt1 first1, InputIt1 last1,
                    InputIt2 first2, OutputIt d_first,
                    BinaryOperation binary_op );

#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> a = {1, 2, 3, 4, 5};
    std::vector<int> b = {10, 20, 30, 40, 50};
    std::vector<int> result(a.size());
    
    // 将两个vector对应元素相加
    std::transform(a.begin(), a.end(), b.begin(), result.begin(),
                   [](int x, int y) { return x + y; });
    
    // 输出：11 22 33 44 55
    for (int x : result) std::cout << x << " ";
    
    return 0;
}

//我们也可以使用back_inserter(result)来写，可以看上面的copy_if
````

# ranges

## 一、定义与核心定位

std::ranges::views（简称 views）是 C++20 标准库中 `ranges` 模块的核心组件之一，本质是对“范围（range）”的轻量级、惰性求值的适配层。其核心作用是：在不修改原始数据、不产生中间拷贝的前提下，对范围（如容器、数组、生成器等）进行过滤、转换、切片等操作，最终生成一个新的“视图”供后续使用。

视图本身不存储数据，仅保存对原始范围的引用（或迭代器对）以及操作逻辑。只有当视图被遍历（如通过循环、算法迭代）时，相关操作才会被实际执行——这种“惰性求值”特性是 views 与传统算法（如 `std::transform`、`std::filter`）的核心区别，也是其高效性的关键。

## 二、核心特性

### 1. 惰性求值（Lazy Evaluation）

视图的创建和组合操作本身不执行任何计算，仅记录操作逻辑。只有当视图被“消费”（如迭代、取值）时，才会逐元素应用所有操作。例如：将 `views::filter` 与 `views::transform` 组合后，遍历视图时会先过滤元素，再对符合条件的元素执行转换，而非先过滤生成中间容器，再转换中间容器。

### 2. 无存储、轻量级

视图不持有数据，仅保存对原始范围的引用和操作状态（如过滤条件、转换函数、切片位置等），因此创建视图的开销极低（通常为常数时间 O(1)），内存占用可忽略。

### 3. 不可修改原始数据

视图默认是“只读”的（除非显式使用可修改视图，如 `views::as_rvalue`），所有操作仅作用于遍历过程中的元素临时值，不会改变原始范围的数据。

### 4. 可组合性（Composability）

多个视图可以通过“管道运算符（|）”轻松组合，形成清晰的操作流水线。例如 `range | views::filter(...) | views::transform(...) | views::take(...)`，逻辑上等同于“先过滤、再转换、最后取前 N 个元素”，代码简洁且可读性高。

### 5. 兼容标准算法

视图本身是“范围（range）”，可直接作为标准范围算法（如 `std::ranges::for_each`、`std::ranges::count`）的输入，无需额外适配。

## 三、常见视图类型及使用示例

`AI` 告诉我可以写成 `std::views::filter` 但是我觉得还是写 `std::ranges::views::filter` 好一点，因为我写的时候报错了。

C++20 标准库提供了数十种内置视图，覆盖过滤、转换、切片、拼接、生成等常见场景，以下是最常用的几种：

### 1. 过滤视图：views::filter

功能：筛选出符合条件的元素，接收一个返回 bool 的谓词函数。

```cpp
#include <ranges>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> nums = {1, 2, 3, 4, 5, 6};
    // 筛选偶数
    auto even_nums = nums | std::ranges::views::filter([](int x) { return x % 2 == 0; });
    
    for (int x : even_nums) {
        std::cout << x << " "; // 输出：2 4 6
    }
    return 0;
}
    
```

### 2. 转换视图：views::transform

功能：对每个元素执行转换操作，接收一个转换函数。

```cpp
#include <ranges>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> nums = {1, 2, 3};
    // 将每个元素乘以 2
    auto doubled = nums | std::ranges::views::transform([](int x) { return x * 2; });
    
    for (int x : doubled) {
        std::cout << x << " "; // 输出：2 4 6
    }
    return 0;
}
    
```

### 3. 切片视图：views::take 与 views::drop

-`views::take(n)`：取前 n 个元素，若不足 n 个则取全部；

\- `views::drop(n)`：跳过前 n 个元素，取剩余元素。

```cpp
#include <ranges>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> nums = {1, 2, 3, 4, 5};
    // 取前 3 个元素
    auto take3 = nums | std::ranges::views::take(3);
    // 跳过前 2 个元素，取剩余
    auto drop2 = nums | std::ranges::views::drop(2);
    
    std::cout << "take(3): ";
    for (int x : take3) std::cout << x << " "; // 输出：1 2 3
    
    std::cout << "\ndrop(2): ";
    for (int x : drop2) std::cout << x << " "; // 输出：3 4 5
    return 0;
}
    
```

### 4. 拼接视图：views::concat

功能：将多个同类型的范围拼接成一个视图（惰性拼接，不产生中间拷贝）。

```cpp
#include <ranges>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> a = {1, 2};
    std::vector<int> b = {3, 4};
    // 拼接 a 和 b
    auto combined = std::ranges::views::concat(a, b);
    
    for (int x : combined) {
        std::cout << x << " "; // 输出：1 2 3 4
    }
    return 0;
}
    
```

### 5. 生成视图：views::iota

功能：生成一个无限递增的整数序列（惰性生成，只有遍历到的元素才会被计算），通常与 `views::take` 配合使用以限制长度。

```cpp
#include <ranges>
#include <iostream>

int main() {
    // 生成 1~5 的序列（从 1 开始，取 5 个元素）
    auto seq = std::ranges::views::iota(1) | std::ranges::views::take(5);
    
    for (int x : seq) {
        std::cout << x << " "; // 输出：1 2 3 4 5
    }
    return 0;
}
    
```



这里我写的作业是22年的，所以题目可能会有一点点不一样，部分assignment答案我都给出了，没给出的是希望大家可以自己去研究一下的（应该不是我懒了）

# assignment1

在看课程的时候，可能会学到`istringstream`跟`ostringstream`，会发现这个东西十分精妙，然后我就跃跃欲试去写了`assignment1`结果发现，我还是大意了。写的时候还是出现了很多问题，在下面一一列举。

1.`ostringstream`写入文件跟`ofstream`写入文件是不一样的（`ifstream`同理），`ostringstream`的输出目标是内存的缓冲区，不是硬盘文件，所以它没有往文件写入数据的功能;`ofstream`的输出目标才是文件，天然支持文件的写入功能。简单来说，你如果要把数据写入文件，只能用`ofstream`。

2.大家应该都会用`find`的吧，就是`string`的库的那个，这一章节只要看懂了**流**的操作，那么这一章就没什么问题了。

以下附上我的代码：

````C++
struct Course {
  std::string title;
  std::string number_of_units;
  std::string quarter;
}
````

````C++
void parse_csv(std::string filename, std::vector<Course> &courses) {
  std::ifstream iss(filename);
  std::string str;
  getline(iss, str);

  while(getline(iss, str)) {
    auto temp = split(str, ',');
    courses.push_back({temp[0], temp[1], temp[2]});
  }
}
````

````C++
void write_courses_offered(std::vector<Course> all_courses) {
  std::ofstream oss("student_output/courses_offered.csv");
  oss << "Title,Number of Units,Quarter\n";

  for(auto p : all_courses) {
    if(p.quarter.find("2023-2024") != -1) oss << p << "\n";  
  }
}
````

````C++
void write_courses_not_offered(std::vector<Course> unlisted_courses) {
  std::ofstream oss("student_output/courses_not_offered.csv");
  oss << "Title,Number of Units,Quarter\n";

  for(auto p : unlisted_courses) {
    if(p.quarter.find("2023-2024") == -1) oss << p << "\n";
  }
}
````

但是如果你这么写你是对不了的，还有一些小问题，还是要去自己找找的，推荐去看看`utils.cpp`的代码。



# assignment2

它还是跟流有关的作业，如果课程已经完全听懂了，那么这章并不难。
这一章需要注意的是，如果你想用`istringstream`的话，必须要头文件`sstream`。

直接上奋吧

## Part1

````c++
std::set<std::string> get_applicants(std::string filename) {
  std::set<std::string> applicant;
  std::ifstream iss(filename);

  std::string str;
  while(getline(iss, str)) {
    applicant.insert(str);
  }

  return applicant;
}
````

## Part2

````c++
//这一段要求是，找出students中，名字首字母之和=kYourName的名字首字母之和。
std::queue<const std::string*> find_matches(std::string name, std::set<std::string>& students) {
  std::istringstream mch(name);
  std::string mtch = "";

  std::queue<const std::string*> ans;

  std::string temp;
  while(mch >> temp) {
    mtch += temp[0];
  }

  for(const auto &stu : students) {
    mch.str(stu);
    std::string s = "";
    while(mch >> temp) {
      s += temp[0];
    }

    if(s == mtch) {
      ans.push(&stu);
    }
  }

  return ans;
}
````

还有一个很神奇的写法，用到了很现代的东西，可以先做了解

````
std::string get_initials(const std::string &text) {
  auto combined_initials = text
                           | std::views::split(' ')
                           | std::views::filter([](auto&& word) { return !word.empty(); })
                           | std::views::transform([](auto&& word) { return *word.begin(); });
  return std::string(combined_initials.begin(), combined_initials.end());
}

std::queue<const std::string*> find_matches(std::string name, std::set<std::string>& students) {
  std::queue<const std::string*> matches;
  std::string given_initials = get_initials(name);
  for (const auto &stu : students) {
    if (get_initials(stu) == given_initials) {
      matches.push(&stu);
    }
  }
  return matches;
}
````

## Part3

````c++
std::string get_match(std::queue<const std::string*>& matches) {
  std::istringstream mch(kYourName);
  std::string mtch = "";

  std::string temp;
  while(mch >> temp) {
    mtch += temp[0];
  }

  while(!matches.empty()){
    std::string stu = *matches.front();
    mch.str(stu);
    std::string s = "";
    while(mch >> temp) {
      s += temp[0];
    }

    if(s == mtch) {
      return stu;
    }
  }
  return "NO MATCHES FOUND.";
}
````



# assignment3

这是一个很简单的作业，就是写一个类需要包含私有的函数，get函数，set函数，构造函数，没有传参的构造函数。
很推荐大家尝试把 `class.h` 跟 `class.cpp` 分开来写

但是有个关键点是，运行代码的时候要执行

````
g++ -std=c++23 main.cpp class.cpp -o main
````



# assignment4

很明显的可以感觉到这个作业已经开始上强度了，很多东西可以用`C++`新一点的函数来写比如，这个作业里面用到的，`std::ranges::views`

## 作业要求Part1

完成 `tokenize` 这个分词函数，将 `source` 这个长字符串分割成一系列的 `Token`，代码中不能使用任何 `for/while` 循环，使用传统的 `STL`。
该 `part` 有三个小任务：1.识别所有指向空格字符的迭代器 2.在连诉的空格字符之间生成词元 3.去除空词元

## 作业要求Part2

完成 `spellcheck` 函数，识别拼写错误并给出拼写建议 ，需要使用全新的 `ranges` 库。
该 `part` 有三个小任务：1.跳过已经拼写正确的单词 2.对拼写不正确的单词，用 `levenshtein `函数来查找范围值为1的单词 3.经过处理后丢弃没有建议的拼写错误。



希望大家先看上面的要求再写lab，因为我之前直接写，没看懂要求。

好了大家先学 `ranges` 库的东西，再来写这个作业。



## Part1

````C++
Corpus tokenize(std::string& source) {
  //todo

  auto space = find_all(source.begin(), source.end(), isspace);
  Corpus tokens;

  std::transform(space.begin(), space.end() - 1, space.begin() + 1, 
    std::inserter(tokens, tokens.end()), 
    [&source](auto &&_first1, auto &&_first2) {
      return Token{source, _first1, _first2};
  }); 

  std::erase_if(tokens, [](const Token &token) { return token.content.empty(); });
  return tokens;
}
````

## Part2

````C++
std::set<Misspelling> spellcheck(const Corpus& source, const Dictionary& dictionary) {  
  //todo
  
  auto view = source 
    | std::ranges::views::filter([&dictionary](const Token &token) {
        return !dictionary.contains(token.content);
      }) 
    | std::ranges::views::transform([&dictionary](const Token &token) -> Misspelling {
        auto dview = dictionary 
          | std::ranges::views::filter([&token](const std::string &str) {
            return levenshtein(token.content, str);
          });
        std::set<std::string> sug(dview.begin(), dview.end());
        return Misspelling{token, sug};
      })
    | std::ranges::views::filter([](const Misspelling &elem) {
      return !elem.suggestions.empty();
      });
  
  return std::set<Misspelling>(view.begin(), view.end());
};
````



多嘴一句，记得编译的时候要用

````
g++ -std=c++23 main.cpp spellcheck.cpp -o main
````



# assignment5

这个作业就是正常的涉及到面向对象中的构造函数，析构函数，以及函数的重载等。

## Part1

编写一个`operator<<`运算符，用于将`User`对象输出到`std::ostream`，多一嘴他应该是一个友元函数。输出样例如下：

````
User(name=Alice, friends=[Bob, Charlie])
````

## Part2

1. 为`User`类实现析构函数。需实现`~User()`特殊成员函数。
2. 使`User`类可拷贝构造。需实现`User(const User& user)`特殊成员函数。
3. 使`User`类可拷贝赋值。需实现`User& operator=(const User& user)`特殊成员函数。
4. 禁止`User`类可移动构造。需删除`User(User&& user)`特殊成员函数。
5. 禁止`User`类可移动赋值。需删除`User& operator=(User&& user)`特殊成员函数。

## Part3

编写一个`operator+=`运算符用于表示将一个用户添加到另一个用户的好友列表中。该操作应是对称的，例如，将Charlie添加到Alice的好友列表时，Alice也应被添加到Charlie的好友列表中。示例代码如下：

```cpp
User alice("Alice");
User charlie("Charlie");

alice += charlie;
std::cout << alice << std::endl;
std::cout << charlie << std::endl;

// 预期输出：
// User(name=Alice, friends=[Charlie])
// User(name=Charlie, friends=[Alice])
```



# assignment6

这个作业已经涉及到一点现代C++的知识了，他要求我们用 `optional` 这是 C++17 引入的非常有用的类型，它表示一个**可能包含值也可能不包含值**的对象。
在写本次作业前，希望大家可以先学一下 `optional` 的相关知识。

### 为什么需要 `optional`？

在没有 `optional` 之前，我们通常使用特殊值来表示"无值"状态：

- 指针：`nullptr`
- 整数：`-1`、`0` 等魔法数字
- 布尔值 + 实际值 的组合

这些方法都不够类型安全且容易出错。

例如，我们应该怎么样使用 `optional` 里面的东西呢。

## 1.创建 `optional` 对象

```
// 空 optional
std::optional<int> empty_opt;
std::optional<int> empty_opt2 = std::nullopt;  // 显式为空

// 包含值的 optional
std::optional<int> opt1(42);
std::optional<int> opt2 = 42;
auto opt3 = std::make_optional(42);  // 自动推导类型

// 原地构造
std::optional<std::string> opt4(std::in_place, "Hello", 5);  // 构造 std::string("Hello")
```

## 2.检查是否包含值

```
std::optional<int> opt = get_value();

// 方法1: has_value()
if (opt.has_value()) {
    // 有值
}

// 方法2: 转换为 bool
if (opt) {
    // 有值
}

// 方法3: value_or() - 有值时返回值，无值时返回默认值
// 没记错的话，这个应该是C++23引入的
int value = opt.value_or(-1);  // 如果opt为空，返回-1
```

## 3.各种操作

| 操作                 | 作用                                                         |
| -------------------- | ------------------------------------------------------------ |
| `std::nullopt`       | 表示空的`optional`，用于赋值或返回空值                       |
| `has_value()`        | 检查`optional`是否包含值，返回`bool`                         |
| `value()`            | 获取值，无值时抛出`std::bad_optional_access`异常（慎用）     |
| `value_or(默认值)`   | 安全获取值：有值则返回值，无值则返回传入的默认值（推荐日常使用） |
| `operator*`/`->`     | 解引用获取值（类似指针），需先确认有值，否则行为未定义       |
| `reset()`            | 清空`optional`的值，使其变为空                               |
| `std::make_optional` | 显式构造`optional`对象，支持类型推导，比直接构造更简洁（推荐） |

### (1) transform

#### 核心作用

如果当前`optional`包含值，就对这个值应用你传入的转换函数，返回一个**新的 optional**（类型由转换函数的返回值决定）；如果当前`optional`为空，直接返回空的`optional`（类型和转换后的一致）。

简单说：`transform`是 “有值就加工，没值就摆烂”。

### (2) or_else

#### 核心作用

如果当前`optional`为空，就执行你传入的备选函数（该函数返回一个同类型的`optional`），并返回这个备选结果；如果当前`optional`有值，直接返回原`optional`（不会执行备选函数）。

简单说：`or_else`是 “没值就找备胎，有值就用自己”。

### (3) transform + or_else 组合使用（实战场景）

这两个函数结合使用时，能实现 “有值就转换，无值就兜底” 的完整逻辑，替代多层 if-else：

```cpp
#include <iostream>
#include <optional>
#include <string>

// 模拟：从配置文件读取端口（可能读取失败，返回空）
std::optional<int> read_port_from_config() {
    // 模拟读取失败
    return std::nullopt;
}

// 模拟：获取默认端口
std::optional<int> get_default_port() {
    std::cout << "使用默认端口" << std::endl;
    return 8080;
}

// 转换：端口转成连接字符串
std::string port_to_conn_str(int port) {
    return "连接地址：localhost:" + std::to_string(port);
}

int main() {
    // 逻辑：读取端口 → 无值则用默认 → 有值则转成连接字符串
    auto conn_str = read_port_from_config()          // 空的optional<int>
        .or_else(get_default_port)                   // 无值，执行备选，返回optional<int>(8080)
        .transform(port_to_conn_str);                // 有值，转换为optional<string>

    std::cout << conn_str.value() << std::endl;      // 输出：连接地址：localhost:8080
    return 0;
}
```

## Part1

完成 `find_course` 函数

## Part2

完成下面对 `output` 的转换。

- 如果找到课程，

  ```bash
  Found course: <课程名称>,<学分>,<开课季度>
  ```

- 如果未找到课程，则上述代码应输出：

  ```bash
  Course not found.
  ```



# assignment7

这次作业主要是看大家对于智能指针的了解，实现类似于 `unique_ptr` 的功能的复现，但是没有很全面的用到智能指针的相关内容，大家可以课后找个例子再多学一下智能指针的相关知识。

### 一、为什么需要智能指针？

首先要明确：**智能指针的核心目的是解决手动管理动态内存的痛点**。C++ 中用`new`分配的堆内存，必须用`delete`手动释放，新手很容易踩坑：

- 忘记`delete` → 内存泄漏；
- 重复`delete` → 未定义行为（程序崩溃）；
- 析构前抛出异常 → 内存泄漏；
- 多个指针指向同一块内存，析构时互相干扰（比如你作业里`unique_ptr`拷贝的问题）。

智能指针是**封装了原生指针的模板类**，遵循**RAII（资源获取即初始化）** 原则：

- 当智能指针对象**创建**时，获取内存资源；
- 当智能指针对象**超出作用域 / 析构**时，自动释放内存（无需手动`delete`）；
- 语义清晰，明确内存的 “所有权”（谁负责释放）。

### 二、C++ 核心智能指针类型

C++11 及以后标准库提供了三种核心智能指针（都在`<memory>`头文件中），其中你作业实现的`unique_ptr`是最基础、最常用的。

#### 1. unique_ptr（独占智能指针）

##### 核心特点

- **独占所有权**：同一时间，只有一个`unique_ptr`能指向同一块内存；
- **不支持拷贝**：禁用了拷贝构造 / 拷贝赋值运算符（你作业里需要删除这两个函数）；
- **支持移动**：可以通过`std::move()`转移所有权（转移后原指针变为`nullptr`）；
- **开销极小**：几乎和原生指针一样快，无额外内存开销；
- **析构时自动释放**：超出作用域时调用`delete`释放内存。

##### 基础用法示例

```cpp
#include <memory>
#include <iostream>

int main() {
    // 1. 创建unique_ptr（优先用make_unique，C++14起支持）
    std::unique_ptr<int> ptr1 = std::make_unique<int>(10);
    // 等价于：std::unique_ptr<int> ptr1(new int(10));（不推荐，易漏释放）

    // 2. 访问数据（和原生指针一样）
    std::cout << *ptr1 << std::endl; // 输出10
    std::cout << ptr1->operator*() << std::endl; // 等价写法（作业里实现的operator*）

    // 3. 移动所有权（不能直接拷贝，必须用std::move）
    std::unique_ptr<int> ptr2 = std::move(ptr1); 
    // 此时ptr1 == nullptr，ptr2指向值为10的内存

    // 4. 重置指针（手动释放/更换指向）
    ptr2.reset(); // 释放内存，ptr2变为nullptr
    ptr2.reset(new int(20)); // 指向新的内存（值为20）

    return 0;
} // ptr2超出作用域，自动释放内存（调用delete）
```

##### 适用场景

- 单个对象 / 资源的独占管理（比如你作业里的链表节点）；
- 函数返回动态分配的对象（避免返回原生指针导致内存泄漏）；
- 容器中存储独占对象（`std::vector<std::unique_ptr<T>>`）。

#### 2. shared_ptr（共享智能指针）

##### 核心特点

- **共享所有权**：多个`shared_ptr`可以指向同一块内存；

- 引用计数

  ：内部维护一个 “引用计数器”（堆上的整数）：

  - 拷贝`shared_ptr` → 计数 + 1；
  - 析构 / 重置`shared_ptr` → 计数 - 1；
  - 当计数为 0 时，自动释放内存；

- **支持拷贝 / 移动**：拷贝会增加计数，移动不改变计数；

- **开销略大**：需要维护引用计数（原子操作，线程安全）。

##### 基础用法示例

```cpp
#include <memory>
#include <iostream>

int main() {
    // 1. 创建shared_ptr（优先用make_shared，更高效）
    std::shared_ptr<int> ptr1 = std::make_shared<int>(100);
    
    // 2. 拷贝：引用计数+1（此时计数=2）
    std::shared_ptr<int> ptr2 = ptr1;
    std::cout << "引用计数：" << ptr1.use_count() << std::endl; // 输出2

    // 3. 访问数据（和unique_ptr一致）
    *ptr2 = 200;
    std::cout << *ptr1 << std::endl; // 输出200（共享同一块内存）

    // 4. 重置：计数-1（ptr1变为nullptr，计数=1）
    ptr1.reset();
    std::cout << "引用计数：" << ptr2.use_count() << std::endl; // 输出1

    return 0;
} // ptr2超出作用域，计数-1=0，释放内存
```

##### 注意：循环引用问题

`shared_ptr`的最大坑是**循环引用**：两个`shared_ptr`互相指向，导致引用计数永远不为 0，内存泄漏。比如：

```cpp
struct Node {
    std::shared_ptr<Node> next; // 互相指向，计数永远为1
};

int main() {
    auto n1 = std::make_shared<Node>();
    auto n2 = std::make_shared<Node>();
    n1->next = n2;
    n2->next = n1;
    return 0; // 析构时n1和n2的计数都是1，内存泄漏！
}
```

#### 3. weak_ptr（弱引用智能指针）

##### 核心特点

- **弱引用**：指向`shared_ptr`管理的内存，但**不拥有所有权**；
- **不增加引用计数**：不会影响内存的释放；
- **需要 lock () 才能访问**：`lock()`会返回一个`shared_ptr`（若内存已释放，返回空）；
- **核心作用**：解决`shared_ptr`的循环引用问题。

##### 解决循环引用的示例

```cpp
struct Node {
    std::weak_ptr<Node> next; // 改用weak_ptr，不增加计数
};

int main() {
    auto n1 = std::make_shared<Node>();
    auto n2 = std::make_shared<Node>();
    n1->next = n2;
    n2->next = n1;
    return 0; // 析构时计数=0，内存正常释放！
}
```





好吧其实我有点懒了，大家可以看一下一下的内容跟 `README.md` 的内容一致，只是翻译了一下。

## 本章作业任务

1. `unique_ptr`类的私有成员部分
2. 构造函数 `unique_ptr(T* ptr)`
3. 支持空指针的构造函数 `unique_ptr(std::nullptr_t)`
4. 解引用运算符 `T& operator*()`
5. 常量版本的解引用运算符 `const T& operator*() const`
6. 成员访问运算符 `T* operator->()`
7. 常量版本的成员访问运算符 `const T* operator->() const`
8. 布尔类型转换运算符 `operator bool() const`

但另一方面，我们**仍然需要支持`unique_ptr`的移动操作**。回顾移动语义的知识点：移动操作可以让我们获取一个对象的资源所有权，且不需要进行昂贵的拷贝操作。移动`unique_ptr`是合法的，因为这能保证指针的 “独占性”—— 任何时刻，始终只有一个指针指向底层内存，我们只是改变了 “谁（哪个变量）拥有这块内存”。

为了实现以下三个核心目标 ——**自动释放内存**、**禁止拷贝**、**支持移动**，你需要为`unique_ptr`类实现一组**特殊成员函数**。具体来说，需要实现以下函数：

1. `~unique_ptr()`：析构函数，释放指针指向的内存
2. `unique_ptr(const unique_ptr& other)`：拷贝构造函数，**需要将其禁用**
3. `unique_ptr& operator=(const unique_ptr& other)`：拷贝赋值运算符，**需要将其禁用**
4. `unique_ptr(unique_ptr&& other)`：移动构造函数
5. `unique_ptr& operator=(unique_ptr&& other)`：移动赋值运算符
